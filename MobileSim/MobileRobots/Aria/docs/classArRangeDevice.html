<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Aria: ArRangeDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>ArRangeDevice Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ArRangeDevice" -->
<p>The base class for all sensing devices which return range information from the device (mounted on a robot) to an object in the environment.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ArRangeDevice.h&gt;</code></p>

<p><a href="classArRangeDevice-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa78f4771a51f82238d69e9932359aa65"></a><!-- doxytag: member="ArRangeDevice::addReading" ref="aa78f4771a51f82238d69e9932359aa65" args="(double x, double y)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aa78f4771a51f82238d69e9932359aa65">addReading</a> (double x, double y)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a reading to the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab7e29948ca6b640272faf43dfe5c4870">applyTransform</a> (<a class="el" href="classArTransform.html">ArTransform</a> trans, bool doCumulative=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a transform to the buffers.  <a href="#ab7e29948ca6b640272faf43dfe5c4870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ae5317e9755d5ef4ddda1acbfd5c79f2f">ArRangeDevice</a> (size_t currentBufferSize, size_t cumulativeBufferSize, const char *name, unsigned int maxRange, int maxSecondsToKeepCurrent=0, int maxSecondsToKeepCumulative=0, double maxDistToKeepCumulative=0, bool locationDependent=false)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#ae5317e9755d5ef4ddda1acbfd5c79f2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20c90a21b4f4a1c51bc9d124e217a8ef"></a><!-- doxytag: member="ArRangeDevice::clearCumulativeOlderThan" ref="a20c90a21b4f4a1c51bc9d124e217a8ef" args="(int milliSeconds)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a20c90a21b4f4a1c51bc9d124e217a8ef">clearCumulativeOlderThan</a> (int milliSeconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the cumulative readings older than this number of milliseconds. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcd491aff714eb3a6924b63d12d65351"></a><!-- doxytag: member="ArRangeDevice::clearCumulativeOlderThanSeconds" ref="adcd491aff714eb3a6924b63d12d65351" args="(int seconds)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#adcd491aff714eb3a6924b63d12d65351">clearCumulativeOlderThanSeconds</a> (int seconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the cumulative readings older than this number of seconds. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82eb3d017534465a60b384ac56f1d2e8"></a><!-- doxytag: member="ArRangeDevice::clearCumulativeReadings" ref="a82eb3d017534465a60b384ac56f1d2e8" args="(void)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a82eb3d017534465a60b384ac56f1d2e8">clearCumulativeReadings</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the cumulative readings. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eb9b6ff83ae33a4a5bbe22eb825d1f5"></a><!-- doxytag: member="ArRangeDevice::clearCurrentReadings" ref="a8eb9b6ff83ae33a4a5bbe22eb825d1f5" args="(void)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a8eb9b6ff83ae33a4a5bbe22eb825d1f5">clearCurrentReadings</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the current readings. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#adeab2edd7763ac30d2b33c1cf08bb915">cumulativeReadingBox</a> (double x1, double y1, double x2, double y2, <a class="el" href="classArPose.html">ArPose</a> *readingPos=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest current reading from the given box region.  <a href="#adeab2edd7763ac30d2b33c1cf08bb915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3c898926eb1c04ed457c8e5c3e7566e3">cumulativeReadingPolar</a> (double startAngle, double endAngle, double *angle=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest cumulative reading in the given polar region.  <a href="#a3c898926eb1c04ed457c8e5c3e7566e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac262870eb43b21b1be17ee8621eb3b91">currentReadingBox</a> (double x1, double y1, double x2, double y2, <a class="el" href="classArPose.html">ArPose</a> *readingPos=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest current reading from the given box region.  <a href="#ac262870eb43b21b1be17ee8621eb3b91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a27b080d64bdedd8f593ffcc6c373d609">currentReadingPolar</a> (double startAngle, double endAngle, double *angle=NULL) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest current reading in the given polar region.  <a href="#a27b080d64bdedd8f593ffcc6c373d609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::list<br class="typebreak"/>
&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a08ad025cfa7204fb601f8b5de95bde9b">getAdjustedRawReadings</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw unfiltered readings from the device (but pose takens are corrected).  <a href="#a08ad025cfa7204fb601f8b5de95bde9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac41b98c9f5fdef7916a09433f871e940">getAdjustedRawReadingsAsVector</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw adjusted readings from the device into a vector.  <a href="#ac41b98c9f5fdef7916a09433f871e940"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::list<br class="typebreak"/>
&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aad3ac9142453f941bc92ba241436453d">getCumulativeBuffer</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings.  <a href="#aad3ac9142453f941bc92ba241436453d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83eb459ed07f7ed361cacc7212db35dd"></a><!-- doxytag: member="ArRangeDevice::getCumulativeBuffer" ref="a83eb459ed07f7ed361cacc7212db35dd" args="(void)" -->
virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a83eb459ed07f7ed361cacc7212db35dd">getCumulativeBuffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aaa8030e121b625a123286f98a328a5b2">getCumulativeBufferAsVector</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cumulative buffer of readings as a vector.  <a href="#aaa8030e121b625a123286f98a328a5b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d14df2fcd274798d4a886a7b926bff"></a><!-- doxytag: member="ArRangeDevice::getCumulativeDrawingData" ref="a69d14df2fcd274798d4a886a7b926bff" args="(void)" -->
virtual <a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a69d14df2fcd274798d4a886a7b926bff">getCumulativeDrawingData</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets data used for visualizing the cumulative buffer (see ArNetworking). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a064f0165f2a406145e6a8939fd17dfb9"></a><!-- doxytag: member="ArRangeDevice::getCumulativeRangeBuffer" ref="a064f0165f2a406145e6a8939fd17dfb9" args="(void)" -->
virtual <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a064f0165f2a406145e6a8939fd17dfb9">getCumulativeRangeBuffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cumulative range buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aefc6078a128d80de304d5b978baaf31d">getCumulativeRangeBuffer</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cumulative range buffer.  <a href="#aefc6078a128d80de304d5b978baaf31d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::list<br class="typebreak"/>
&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a072ac84980687ed353b3e5c2e36d6d68">getCurrentBuffer</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings.  <a href="#a072ac84980687ed353b3e5c2e36d6d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1395143f849a819e08a10bf6542503ca"></a><!-- doxytag: member="ArRangeDevice::getCurrentBuffer" ref="a1395143f849a819e08a10bf6542503ca" args="(void)" -->
virtual std::list<br class="typebreak"/>
&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a1395143f849a819e08a10bf6542503ca">getCurrentBuffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a91c1207063423f113406c9de528fc320">getCurrentBufferAsVector</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings as a vector.  <a href="#a91c1207063423f113406c9de528fc320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbebb9e3252d1449acff674ebc0c7a10"></a><!-- doxytag: member="ArRangeDevice::getCurrentDrawingData" ref="acbebb9e3252d1449acff674ebc0c7a10" args="(void)" -->
virtual <a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#acbebb9e3252d1449acff674ebc0c7a10">getCurrentDrawingData</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets data used for visualizing the current buffer (see ArNetworking). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6690dffb87973976b557b8190162e8"></a><!-- doxytag: member="ArRangeDevice::getCurrentRangeBuffer" ref="acf6690dffb87973976b557b8190162e8" args="(void)" -->
virtual <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#acf6690dffb87973976b557b8190162e8">getCurrentRangeBuffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current range buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad5e497d7893beb13ef903861ba909087">getCurrentRangeBuffer</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current range buffer.  <a href="#ad5e497d7893beb13ef903861ba909087"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aefc5cdd9adb55399d4e0725754c418ca">getMaxDistToKeepCumulative</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the maximum distance cumulative readings can be from current pose  <a href="#aefc5cdd9adb55399d4e0725754c418ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a506d33c0b4e405476ce2b56097bcbce8">getMaxInsertDistCumulative</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the maximum distance a cumulative reading can be from the robot and still be inserted.  <a href="#a506d33c0b4e405476ce2b56097bcbce8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1bb050d30a525eb5a4b032c803d356c"></a><!-- doxytag: member="ArRangeDevice::getMaxRange" ref="ad1bb050d30a525eb5a4b032c803d356c" args="(void)" -->
virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad1bb050d30a525eb5a4b032c803d356c">getMaxRange</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the maximum range for this device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3f9c853607709dd259d406c0356edc5b">getMaxSecondsToKeepCumulative</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the maximum seconds to keep current readings around  <a href="#a3f9c853607709dd259d406c0356edc5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a51152724f047e69c2aec79bde36ece1f">getMaxSecondsToKeepCurrent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the maximum seconds to keep current readings around  <a href="#a51152724f047e69c2aec79bde36ece1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a900eac07d508c59f5026e423e7777864">getMinDistBetweenCumulative</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the minimum distance between cumulative readings.  <a href="#a900eac07d508c59f5026e423e7777864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#aaafc983b6f747863b93c5258b18a4076">getMinDistBetweenCurrent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the minimum distance between current readings.  <a href="#aaafc983b6f747863b93c5258b18a4076"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf76b644d209c28628a1f7ba4047b60b"></a><!-- doxytag: member="ArRangeDevice::getName" ref="adf76b644d209c28628a1f7ba4047b60b" args="(void) const " -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#adf76b644d209c28628a1f7ba4047b60b">getName</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const std::list<br class="typebreak"/>
&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac3f1591ab4bcd08ffeab0254aaf7568b">getRawReadings</a> (void) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw unfiltered readings from the device.  <a href="#ac3f1591ab4bcd08ffeab0254aaf7568b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector<br class="typebreak"/>
&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a97fdf4c7e7c95ac8e5605df3c87ee1dc">getRawReadingsAsVector</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw unfiltered readings from the device into a vector.  <a href="#a97fdf4c7e7c95ac8e5605df3c87ee1dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70473f04371cb1b4bcac83f1e2cd5a2"></a><!-- doxytag: member="ArRangeDevice::getRobot" ref="ae70473f04371cb1b4bcac83f1e2cd5a2" args="(void)" -->
virtual <a class="el" href="classArRobot.html">ArRobot</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ae70473f04371cb1b4bcac83f1e2cd5a2">getRobot</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the robot this device is attached to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22e4bf48910f725221760a202206a1e9"></a><!-- doxytag: member="ArRangeDevice::isLocationDependent" ref="a22e4bf48910f725221760a202206a1e9" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a22e4bf48910f725221760a202206a1e9">isLocationDependent</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets if this device is location dependent or not. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172e8da71d800f959523e1f3021612d8"></a><!-- doxytag: member="ArRangeDevice::lockDevice" ref="a172e8da71d800f959523e1f3021612d8" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a172e8da71d800f959523e1f3021612d8">lockDevice</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock this device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad4f7fa1ed25b92afed4de0cb957c313c">setCumulativeBufferSize</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum size of the buffer for cumulative readings.  <a href="#ad4f7fa1ed25b92afed4de0cb957c313c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5ac42251d038f50250117e7ae21cbdc"></a><!-- doxytag: member="ArRangeDevice::setCumulativeDrawingData" ref="ac5ac42251d038f50250117e7ae21cbdc" args="(ArDrawingData *data, bool takeOwnershipOfData)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ac5ac42251d038f50250117e7ae21cbdc">setCumulativeDrawingData</a> (<a class="el" href="classArDrawingData.html">ArDrawingData</a> *data, bool takeOwnershipOfData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets data for visualizing the cumulative buffer (and if we own it). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a0e73bae003a4e3f89f8bddfc843db464">setCurrentBufferSize</a> (size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum size of the buffer for current readings.  <a href="#a0e73bae003a4e3f89f8bddfc843db464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b09eb692d4c9d0f9b51cca41f9e9665"></a><!-- doxytag: member="ArRangeDevice::setCurrentDrawingData" ref="a7b09eb692d4c9d0f9b51cca41f9e9665" args="(ArDrawingData *data, bool takeOwnershipOfData)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7b09eb692d4c9d0f9b51cca41f9e9665">setCurrentDrawingData</a> (<a class="el" href="classArDrawingData.html">ArDrawingData</a> *data, bool takeOwnershipOfData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets data for visualizing the current buffer (and if we own it). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3f1ec2efa5f2d6d34683586919847aa2">setMaxDistToKeepCumulative</a> (double maxDistToKeepCumulative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the maximum distance cumulative readings can be from current pose  <a href="#a3f1ec2efa5f2d6d34683586919847aa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a65aaec7f213c343f6c096584928463cc">setMaxInsertDistCumulative</a> (double maxInsertDistCumulative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum distance a cumulative reading can be from the robot and still be inserted.  <a href="#a65aaec7f213c343f6c096584928463cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a31e62e62d21f870c2b4f2f8ec5ceee"></a><!-- doxytag: member="ArRangeDevice::setMaxRange" ref="a7a31e62e62d21f870c2b4f2f8ec5ceee" args="(unsigned int maxRange)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7a31e62e62d21f870c2b4f2f8ec5ceee">setMaxRange</a> (unsigned int maxRange)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum range for this device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a6d797854910a43b6650fb4cee3d8626f">setMaxSecondsToKeepCumulative</a> (int maxSecondsToKeepCumulative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the maximum seconds to keep cumulative readings around  <a href="#a6d797854910a43b6650fb4cee3d8626f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab963e49e5a08704ac08ab7eab040fa8c">setMaxSecondsToKeepCurrent</a> (int maxSecondsToKeepCurrent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum seconds to keep current readings around.  <a href="#ab963e49e5a08704ac08ab7eab040fa8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#acd53bf7cfbba205118c79ab95c8c3f18">setMinDistBetweenCumulative</a> (double minDistBetweenCumulative)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the minimum distance between cumulative readings.  <a href="#acd53bf7cfbba205118c79ab95c8c3f18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab3b9e8840205f7d1b60a55f27490c1ab">setMinDistBetweenCurrent</a> (double minDistBetweenCurrent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the minimum distance between current readings.  <a href="#ab3b9e8840205f7d1b60a55f27490c1ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5d3eeb36b5347c006e844ee7a103b96"></a><!-- doxytag: member="ArRangeDevice::setRobot" ref="ab5d3eeb36b5347c006e844ee7a103b96" args="(ArRobot *robot)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ab5d3eeb36b5347c006e844ee7a103b96">setRobot</a> (<a class="el" href="classArRobot.html">ArRobot</a> *robot)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the robot this device is attached to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f74c2d3090f1c6d94c24bdec580165"></a><!-- doxytag: member="ArRangeDevice::tryLockDevice" ref="ad9f74c2d3090f1c6d94c24bdec580165" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#ad9f74c2d3090f1c6d94c24bdec580165">tryLockDevice</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock this device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af889a070950aae211df4637fbb73608e"></a><!-- doxytag: member="ArRangeDevice::unlockDevice" ref="af889a070950aae211df4637fbb73608e" args="()" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#af889a070950aae211df4637fbb73608e">unlockDevice</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock this device. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a166b2f88c88663ba337db50a008b5e83"></a><!-- doxytag: member="ArRangeDevice::~ArRangeDevice" ref="a166b2f88c88663ba337db50a008b5e83" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a166b2f88c88663ba337db50a008b5e83">~ArRangeDevice</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7774762a642a206a3b57bac9876ba5af">adjustRawReadings</a> (bool interlaced)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf6c1ba0cd2ac91887cac2856e048c77"></a><!-- doxytag: member="ArRangeDevice::filterCallback" ref="aaf6c1ba0cd2ac91887cac2856e048c77" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>filterCallback</b> (void)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6d02a16900d73887a8004d3e239278"></a><!-- doxytag: member="ArRangeDevice::myAdjustedRawReadings" ref="afa6d02a16900d73887a8004d3e239278" args="" -->
std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myAdjustedRawReadings</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8db7c1b2099396b066f5645e80547e93"></a><!-- doxytag: member="ArRangeDevice::myAdjustedRawReadingsVector" ref="a8db7c1b2099396b066f5645e80547e93" args="" -->
std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myAdjustedRawReadingsVector</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5ce26c1762c4bb167601c3c09260bbe"></a><!-- doxytag: member="ArRangeDevice::myCumulativeBuffer" ref="ad5ce26c1762c4bb167601c3c09260bbe" args="" -->
<a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCumulativeBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace130bb2f40f0179bd455df84cb8bd88"></a><!-- doxytag: member="ArRangeDevice::myCumulativeDrawingData" ref="ace130bb2f40f0179bd455df84cb8bd88" args="" -->
<a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCumulativeDrawingData</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8be8e72cbac3f38c430c72b279de2a6"></a><!-- doxytag: member="ArRangeDevice::myCurrentBuffer" ref="af8be8e72cbac3f38c430c72b279de2a6" args="" -->
<a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCurrentBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d810d3867aa7be92560b6228f8717b"></a><!-- doxytag: member="ArRangeDevice::myCurrentDrawingData" ref="a69d810d3867aa7be92560b6228f8717b" args="" -->
<a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCurrentDrawingData</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ffcd7fc1f49cf175686e22c9b4fd43f"></a><!-- doxytag: member="ArRangeDevice::myDeviceMutex" ref="a9ffcd7fc1f49cf175686e22c9b4fd43f" args="" -->
<a class="el" href="classArMutex.html">ArMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myDeviceMutex</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6032f65f02bb4bc14dacb2eee628a64c"></a><!-- doxytag: member="ArRangeDevice::myFilterCB" ref="a6032f65f02bb4bc14dacb2eee628a64c" args="" -->
<a class="el" href="classArFunctorC.html">ArFunctorC</a>&lt; <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myFilterCB</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2222f1480d57c93193b861c087c7d502"></a><!-- doxytag: member="ArRangeDevice::myIsLocationDependent" ref="a2222f1480d57c93193b861c087c7d502" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myIsLocationDependent</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c63c8b7f611a97f98428d5f018c4a6"></a><!-- doxytag: member="ArRangeDevice::myMaxDistToKeepCumulative" ref="ad0c63c8b7f611a97f98428d5f018c4a6" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxDistToKeepCumulative</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab74723892344efd4e702b174d345736"></a><!-- doxytag: member="ArRangeDevice::myMaxDistToKeepCumulativeSquared" ref="aab74723892344efd4e702b174d345736" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxDistToKeepCumulativeSquared</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3383185644b9a1ce860e7d13001838d5"></a><!-- doxytag: member="ArRangeDevice::myMaxInsertDistCumulative" ref="a3383185644b9a1ce860e7d13001838d5" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulative</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b3dd8bb3d34a534514dc8112afba00"></a><!-- doxytag: member="ArRangeDevice::myMaxInsertDistCumulativePose" ref="a21b3dd8bb3d34a534514dc8112afba00" args="" -->
<a class="el" href="classArPose.html">ArPose</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulativePose</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc9a9e1f96b36ac5685bbfe706cfe204"></a><!-- doxytag: member="ArRangeDevice::myMaxInsertDistCumulativeSquared" ref="adc9a9e1f96b36ac5685bbfe706cfe204" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulativeSquared</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c35fe4536d577557a9942276ab41fce"></a><!-- doxytag: member="ArRangeDevice::myMaxRange" ref="a8c35fe4536d577557a9942276ab41fce" args="" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxRange</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a309f620a84332c7c1258548776494978"></a><!-- doxytag: member="ArRangeDevice::myMaxSecondsToKeepCumulative" ref="a309f620a84332c7c1258548776494978" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxSecondsToKeepCumulative</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c58006d4790190630b2a2543aedd37"></a><!-- doxytag: member="ArRangeDevice::myMaxSecondsToKeepCurrent" ref="ae5c58006d4790190630b2a2543aedd37" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxSecondsToKeepCurrent</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9500f36938ed5273ba048bec649cba4c"></a><!-- doxytag: member="ArRangeDevice::myMinDistBetweenCumulative" ref="a9500f36938ed5273ba048bec649cba4c" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCumulative</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7386deb78492c085340c3b9de8f467f"></a><!-- doxytag: member="ArRangeDevice::myMinDistBetweenCumulativeSquared" ref="ad7386deb78492c085340c3b9de8f467f" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCumulativeSquared</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11ca0e64151e39728b80114f39e4499b"></a><!-- doxytag: member="ArRangeDevice::myMinDistBetweenCurrent" ref="a11ca0e64151e39728b80114f39e4499b" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCurrent</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00af2617c176f3726702f4208d14b156"></a><!-- doxytag: member="ArRangeDevice::myMinDistBetweenCurrentSquared" ref="a00af2617c176f3726702f4208d14b156" args="" -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCurrentSquared</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e41abc839a5525f42f6d8ead74a71ab"></a><!-- doxytag: member="ArRangeDevice::myName" ref="a5e41abc839a5525f42f6d8ead74a71ab" args="" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6091650d6b5882f21c11eb393ae56aa"></a><!-- doxytag: member="ArRangeDevice::myOwnCumulativeDrawingData" ref="af6091650d6b5882f21c11eb393ae56aa" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myOwnCumulativeDrawingData</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad57fee938b1b73104400fa033a74aa"></a><!-- doxytag: member="ArRangeDevice::myOwnCurrentDrawingData" ref="a9ad57fee938b1b73104400fa033a74aa" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myOwnCurrentDrawingData</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea5307cac3fefd997e644307f6c5c129"></a><!-- doxytag: member="ArRangeDevice::myRawReadings" ref="aea5307cac3fefd997e644307f6c5c129" args="" -->
std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRawReadings</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3053a123a93b8c8f9e4e92838136f6aa"></a><!-- doxytag: member="ArRangeDevice::myRawReadingsVector" ref="a3053a123a93b8c8f9e4e92838136f6aa" args="" -->
std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRawReadingsVector</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29abe2d368550e7a5756ece2908aadc6"></a><!-- doxytag: member="ArRangeDevice::myRobot" ref="a29abe2d368550e7a5756ece2908aadc6" args="" -->
<a class="el" href="classArRobot.html">ArRobot</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRobot</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The base class for all sensing devices which return range information from the device (mounted on a robot) to an object in the environment. </p>
<p>This class maintains two <a class="el" href="classArRangeBuffer.html" title="This class is a buffer that holds ranging information.">ArRangeBuffer</a> objects: a current buffer for storing very recent readings, and a cumulative buffer for a longer history of readings. The maximum sizes of each buffer can be set in the constructor or resized later. Range device readings are most often represented as a point in space (X,Y) where the sensor detected an object. (Therefore an <a class="el" href="classArPose.html" title="The class which represents an x/y position along with a heading.">ArPose</a> object may only have X and Y components set). Some devices provide extra information in a "raw" buffer, or in lists of more detailed ArSensoReading objects.</p>
<p>Subclasses are used for specific sensor implementations like ArSick for SICK lasers and <a class="el" href="classArSonarDevice.html" title="Keep track of recent sonar readings from a robot as an ArRangeDevice.">ArSonarDevice</a> for the Pioneer sonar array. It can also be useful to treat "virtual" objects like forbidden areas specified by the user in a map like range devices. Some of these subsclasses may use a separate thread to update the range reading buffers, and so this base class provides "lock" and "unlock" methods which you should use when accessing device data.</p>
<p>A range device may have an <a class="el" href="classArRobot.html" title="Central class for communicating with and operating the robot.">ArRobot</a> object associated with it. A range device may also be associated with an <a class="el" href="classArRobot.html" title="Central class for communicating with and operating the robot.">ArRobot</a> by calling <a class="el" href="classArRobot.html#a97d57b28549fdef851c00749a97cc776" title="Adds a rangeDevice to the robot&#39;s list of them, and set the device&#39;s robot pointer...">ArRobot::addRangeDevice()</a>. <a class="el" href="classArRobot.html" title="Central class for communicating with and operating the robot.">ArRobot</a> provides functions which operate on all such associated <a class="el" href="classArRangeDevice.html" title="The base class for all sensing devices which return range information from the device (mounted on a r...">ArRangeDevice</a> objects. This is a convenient (and thread-safe) way to access all range device data without depending on a specific set of individual range devices. For example, you can find the closest reading in a box or a polar section, no matter if that reading originated from the sonar, a laser, or other device. </p>
<dl><dt><b>Examples: </b></dt><dd>
<p><a class="el" href="actionExample_8cpp-example.html#_a5">actionExample.cpp</a>.</p>
</dd>
</dl><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae5317e9755d5ef4ddda1acbfd5c79f2f"></a><!-- doxytag: member="ArRangeDevice::ArRangeDevice" ref="ae5317e9755d5ef4ddda1acbfd5c79f2f" args="(size_t currentBufferSize, size_t cumulativeBufferSize, const char *name, unsigned int maxRange, int maxSecondsToKeepCurrent=0, int maxSecondsToKeepCumulative=0, double maxDistToKeepCumulative=0, bool locationDependent=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArRangeDevice::ArRangeDevice </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>currentBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>cumulativeBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSecondsToKeepCurrent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSecondsToKeepCumulative</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>maxDistToKeepCumulative</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>locationDependent</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentBufferSize</em>&nbsp;</td><td>number of readings to store in the current buffer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cumulativeBufferSize</em>&nbsp;</td><td>number of readings to store in the cumulative buffer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of this device</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxRange</em>&nbsp;</td><td>the maximum range of this device. If the device can't find a reading in a specified section, it returns this maxRange</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCurrent</em>&nbsp;</td><td>this is the number of seconds to keep current readings in the current buffer. If less than 0, then readings are not automatically removed based on time (but can be replaced or removed for other reasons).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCumulative</em>&nbsp;</td><td>this is the number of seconds to keep cumulative readings in the cumulative buffer. If less than 0 then readings are not automatically based on time (but can be replaced or removed for other reasons).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxDistToKeepCumulative</em>&nbsp;</td><td>if cumulative readings are further than this distance from the current robot pose, then they are removed. If this is less than 0 they are not removed because of this</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locationDependent</em>&nbsp;</td><td>if the data in this range device is dependent on the robot's location or not... For instance, a laser would not be dependent on location, because it'll be correct in a relative manner, whereas forbidden lines are dependent on location, because if the robot isn't where it thinks it is then the forbidden lines will be avoided in the wrong spots... this is mainly just a flag for other things to use when deciding what range devices to avoid</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>planar</em>&nbsp;</td><td>if the range device is planar or not... planar range devices are ones like the Sick LMS200 that are only in one plane and and are all measured from a single point... Where you can use the beams of the current reading to filter out any cumulative readings that are close to the beam... these range devices need to simply build a set of raw readings and then call 'planarProcessReadings' for this filtering to work </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7774762a642a206a3b57bac9876ba5af"></a><!-- doxytag: member="ArRangeDevice::adjustRawReadings" ref="a7774762a642a206a3b57bac9876ba5af" args="(bool interlaced)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::adjustRawReadings </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interlaced</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This call should be called by the range device every robot cycle before the range device makes new readings (and even if it isn't adding any that cycle)... it will adjust the raw readings by the robot odometry offset. The robot should be locked when this happens (which should be the case if you're doing it in the robot callback). The code currently assumes that all readings were taken at the same point, so if that isn't true with your device then you can't use this mechanism. </p>

</div>
</div>
<a class="anchor" id="ab7e29948ca6b640272faf43dfe5c4870"></a><!-- doxytag: member="ArRangeDevice::applyTransform" ref="ab7e29948ca6b640272faf43dfe5c4870" args="(ArTransform trans, bool doCumulative=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::applyTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArTransform.html">ArTransform</a>&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doCumulative</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a transform to the buffers. </p>
<p>Applies a coordinate transformation to some or all buffers. This is mostly useful for translating to/from local/global coordinate systems, but may have other uses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>trans</em>&nbsp;</td><td>the transform to apply to the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doCumulative</em>&nbsp;</td><td>whether to transform the cumulative buffer or not </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArLaser.html#a550a8f6002f7c6be0755d4ca5eb064a9">ArLaser</a>.</p>

</div>
</div>
<a class="anchor" id="adeab2edd7763ac30d2b33c1cf08bb915"></a><!-- doxytag: member="ArRangeDevice::cumulativeReadingBox" ref="adeab2edd7763ac30d2b33c1cf08bb915" args="(double x1, double y1, double x2, double y2, ArPose *readingPos=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::cumulativeReadingBox </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArPose.html">ArPose</a> *&nbsp;</td>
          <td class="paramname"> <em>pose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the closest current reading from the given box region. </p>
<p>Get the closest reading in the cumulative buffer within a rectangular region around the range device, defined by two points (opposeite points of a rectangle). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>the x coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y1</em>&nbsp;</td><td>the y coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>the x coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y2</em>&nbsp;</td><td>the y coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pose</em>&nbsp;</td><td>a pointer to an <a class="el" href="classArPose.html" title="The class which represents an x/y position along with a heading.">ArPose</a> object in which to store the location of the closest position </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The range to the reading from the device, or a value &gt;= maxRange if no reading was found in the box. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c898926eb1c04ed457c8e5c3e7566e3"></a><!-- doxytag: member="ArRangeDevice::cumulativeReadingPolar" ref="a3c898926eb1c04ed457c8e5c3e7566e3" args="(double startAngle, double endAngle, double *angle=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::cumulativeReadingPolar </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>angle</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the closest cumulative reading in the given polar region. </p>
<p>The closest reading in this range device's cumulative buffer within a polar region or "slice" defined by the given angle range is returned. Optionally return the specific angle of the found reading as well. The region searched is the region between a starting angle, sweeping counter-clockwise to the ending angle (0 is straight ahead of the device, -90 to the right, 90 to the left). Note that there is a difference between the region (0, 10) and (10, 0). (0, 10) is a 10-degree span near the front of the device, while (10, 0) is a 350 degree span covering the sides and rear. Similarly, (-60, -30) covers 30 degrees on the right hand side, while (-30, -60) covers 330 degrees. In other words, if you want the smallest section between the two angles, ensure than startAngle &lt; endAngle. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startAngle</em>&nbsp;</td><td>where to start the slice </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endAngle</em>&nbsp;</td><td>where to end the slice, going counterclockwise from startAngle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>if given, a pointer to a value in which to put the specific angle to the found reading </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the range to the obstacle (a value &gt;= the maximum range indicates that no reading was detected in the specified region)</dd></dl>
<p>Example: </p>
<div align="center">
<img src="ArRangeDevice_currentReadingPolar.png" alt="ArRangeDevice_currentReadingPolar.png"/>
<p><strong>This figure illustrates an example range device and the meanings of arguments and return value.</strong></p></div>
 
</div>
</div>
<a class="anchor" id="ac262870eb43b21b1be17ee8621eb3b91"></a><!-- doxytag: member="ArRangeDevice::currentReadingBox" ref="ac262870eb43b21b1be17ee8621eb3b91" args="(double x1, double y1, double x2, double y2, ArPose *readingPos=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::currentReadingBox </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArPose.html">ArPose</a> *&nbsp;</td>
          <td class="paramname"> <em>pose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the closest current reading from the given box region. </p>
<p>Get the closest reading in the current buffer within a rectangular region defined by two points (opposite corners of the rectangle). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>the x coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y1</em>&nbsp;</td><td>the y coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>the x coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y2</em>&nbsp;</td><td>the y coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pose</em>&nbsp;</td><td>a pointer to an <a class="el" href="classArPose.html" title="The class which represents an x/y position along with a heading.">ArPose</a> object in which to store the location of the closest position </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The range to the reading from the device, or a value &gt;= maxRange if no reading was found in the box. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b080d64bdedd8f593ffcc6c373d609"></a><!-- doxytag: member="ArRangeDevice::currentReadingPolar" ref="a27b080d64bdedd8f593ffcc6c373d609" args="(double startAngle, double endAngle, double *angle=NULL) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::currentReadingPolar </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>angle</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the closest current reading in the given polar region. </p>
<p>The closest reading within a polar region or "slice" defined by the given angle range is returned. Optionally, the specific angle of the found may be placed in <em>angle</em>, if not NULL. The region searched is the region between <em>startAngle</em>, sweeping counter-clockwise to <em>endAngle</em> (0 is straight ahead of the device, -90 to the right, 90 to the left). Note that therefore there is a difference between e.g. the regions (0, 10) and (10, 0). (0, 10) is a 10-degree span near the front of the device, while (10, 0) is a 350 degree span covering the sides and rear. Similarly, (-60, -30) covers 30 degrees on the right hand side, while (-30, -60) covers 330 degrees. (-90, 90) is 180 degrees in front. (-180, 180) covers all sides of the robot. In other words, if you want the smallest section between the two angles, ensure that <em>startAngle</em> &lt; <em>endAngle</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startAngle</em>&nbsp;</td><td>where to start the slice </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endAngle</em>&nbsp;</td><td>where to end the slice, going counterclockwise from startAngle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>if given, a pointer to a value in which to put the specific angle to the found reading </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the range to the obstacle (a value &gt;= the maximum range indicates that no reading was detected in the specified region)</dd></dl>
<p>Example: </p>
<div align="center">
<img src="ArRangeDevice_currentReadingPolar.png" alt="ArRangeDevice_currentReadingPolar.png"/>
<p><strong>This figure illustrates an example range device and the meanings of arguments and return value.</strong></p></div>
 
</div>
</div>
<a class="anchor" id="a08ad025cfa7204fb601f8b5de95bde9b"></a><!-- doxytag: member="ArRangeDevice::getAdjustedRawReadings" ref="a08ad025cfa7204fb601f8b5de95bde9b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArSensorReading.html">ArSensorReading</a> *&gt;* ArRangeDevice::getAdjustedRawReadings </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the raw unfiltered readings from the device (but pose takens are corrected). </p>
<p>The raw readings are the full set of unfiltered readings from the device. They are the latest readings. You should not manipulate the list you get from this function, the only manipulation of this list should be done by the range device itself. (Its only pointers for speed.)</p>
<p>This is like the raw readings but they were corrected for the robot odometry offset (just the pose taken, and encoder psoe taken).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only ArSick provides this data currently. Sonar, bumpers, etc. do not provide raw readings. This method was added to this base class for future lasers or other similar devices. Other kinds of range devices are sufficiently different from lasers that any "raw" information provided would usually require very different interpretation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac41b98c9f5fdef7916a09433f871e940"></a><!-- doxytag: member="ArRangeDevice::getAdjustedRawReadingsAsVector" ref="ac41b98c9f5fdef7916a09433f871e940" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; * ArRangeDevice::getAdjustedRawReadingsAsVector </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the raw adjusted readings from the device into a vector. </p>
<p>Copies the list into a vector. </p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArSensorReadingVector instead of the std::vector template type. </p>

</div>
</div>
<a class="anchor" id="aad3ac9142453f941bc92ba241436453d"></a><!-- doxytag: member="ArRangeDevice::getCumulativeBuffer" ref="aad3ac9142453f941bc92ba241436453d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> *&gt;* ArRangeDevice::getCumulativeBuffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current buffer of readings. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#aaa8030e121b625a123286f98a328a5b2" title="Gets the cumulative buffer of readings as a vector.">getCumulativeBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="aaa8030e121b625a123286f98a328a5b2"></a><!-- doxytag: member="ArRangeDevice::getCumulativeBufferAsVector" ref="aaa8030e121b625a123286f98a328a5b2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a>&gt;* ArRangeDevice::getCumulativeBufferAsVector </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the cumulative buffer of readings as a vector. </p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArPoseWithTimeVector instead of the std::vector template. </p>

</div>
</div>
<a class="anchor" id="aefc6078a128d80de304d5b978baaf31d"></a><!-- doxytag: member="ArRangeDevice::getCumulativeRangeBuffer" ref="aefc6078a128d80de304d5b978baaf31d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>* ArRangeDevice::getCumulativeRangeBuffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the cumulative range buffer. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#aaa8030e121b625a123286f98a328a5b2" title="Gets the cumulative buffer of readings as a vector.">getCumulativeBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="a072ac84980687ed353b3e5c2e36d6d68"></a><!-- doxytag: member="ArRangeDevice::getCurrentBuffer" ref="a072ac84980687ed353b3e5c2e36d6d68" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> *&gt;* ArRangeDevice::getCurrentBuffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current buffer of readings. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a91c1207063423f113406c9de528fc320" title="Gets the current buffer of readings as a vector.">getCurrentBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="a91c1207063423f113406c9de528fc320"></a><!-- doxytag: member="ArRangeDevice::getCurrentBufferAsVector" ref="a91c1207063423f113406c9de528fc320" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a>&gt;* ArRangeDevice::getCurrentBufferAsVector </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current buffer of readings as a vector. </p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArPoseWithTimeVector instead of the std::vector template. </p>

</div>
</div>
<a class="anchor" id="ad5e497d7893beb13ef903861ba909087"></a><!-- doxytag: member="ArRangeDevice::getCurrentRangeBuffer" ref="ad5e497d7893beb13ef903861ba909087" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>* ArRangeDevice::getCurrentRangeBuffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current range buffer. </p>
<p><b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a91c1207063423f113406c9de528fc320" title="Gets the current buffer of readings as a vector.">getCurrentBufferAsVector()</a> </p>

</div>
</div>
<a class="anchor" id="aefc5cdd9adb55399d4e0725754c418ca"></a><!-- doxytag: member="ArRangeDevice::getMaxDistToKeepCumulative" ref="aefc5cdd9adb55399d4e0725754c418ca" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMaxDistToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets the maximum distance cumulative readings can be from current pose </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>if cumulative readings are further than this from where the current pose they are removed, if this is less than 0 they are not removed because of this </dd></dl>

</div>
</div>
<a class="anchor" id="a506d33c0b4e405476ce2b56097bcbce8"></a><!-- doxytag: member="ArRangeDevice::getMaxInsertDistCumulative" ref="a506d33c0b4e405476ce2b56097bcbce8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMaxInsertDistCumulative </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the maximum distance a cumulative reading can be from the robot and still be inserted. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum distance a cumulative reading can have from the robot's current position and still be inserted into the cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f9c853607709dd259d406c0356edc5b"></a><!-- doxytag: member="ArRangeDevice::getMaxSecondsToKeepCumulative" ref="a3f9c853607709dd259d406c0356edc5b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArRangeDevice::getMaxSecondsToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the maximum seconds to keep current readings around </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>this is the number of seconds cumulative readings are kept around for, if less than 0 then they are not automatically removed because of this </dd></dl>

</div>
</div>
<a class="anchor" id="a51152724f047e69c2aec79bde36ece1f"></a><!-- doxytag: member="ArRangeDevice::getMaxSecondsToKeepCurrent" ref="a51152724f047e69c2aec79bde36ece1f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ArRangeDevice::getMaxSecondsToKeepCurrent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the maximum seconds to keep current readings around </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>this is the number of seconds current readings are kept around for, if less than 0 then they are not automatically removed because of this </dd></dl>

</div>
</div>
<a class="anchor" id="a900eac07d508c59f5026e423e7777864"></a><!-- doxytag: member="ArRangeDevice::getMinDistBetweenCumulative" ref="a900eac07d508c59f5026e423e7777864" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMinDistBetweenCumulative </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the minimum distance between cumulative readings. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The minimum distance between cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="aaafc983b6f747863b93c5258b18a4076"></a><!-- doxytag: member="ArRangeDevice::getMinDistBetweenCurrent" ref="aaafc983b6f747863b93c5258b18a4076" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ArRangeDevice::getMinDistBetweenCurrent </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the minimum distance between current readings. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The minimum distance between current readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f1591ab4bcd08ffeab0254aaf7568b"></a><!-- doxytag: member="ArRangeDevice::getRawReadings" ref="ac3f1591ab4bcd08ffeab0254aaf7568b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::list&lt;<a class="el" href="classArSensorReading.html">ArSensorReading</a> *&gt;* ArRangeDevice::getRawReadings </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the raw unfiltered readings from the device. </p>
<p>The raw readings are the full set of unfiltered readings from the device. They are the latest readings. You should not manipulate the list you get from this function, the only manipulation of this list should be done by the range device itself. (Its only pointers for speed.)</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Only ArSick provides this data currently. Sonar, bumpers, etc. do not provide raw readings. This method was added to this base class for future lasers or other similar devices. Other kinds of range devices are sufficiently different from lasers that any "raw" information provided would usually require very different interpretation. </dd></dl>

</div>
</div>
<a class="anchor" id="a97fdf4c7e7c95ac8e5605df3c87ee1dc"></a><!-- doxytag: member="ArRangeDevice::getRawReadingsAsVector" ref="a97fdf4c7e7c95ac8e5605df3c87ee1dc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; * ArRangeDevice::getRawReadingsAsVector </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the raw unfiltered readings from the device into a vector. </p>
<p>Copies the list into a vector. </p>
<p><b>Java and Python Wrappers:</b> The return type will be named ArSensorReadingVector instead of the std::vector template type. </p>

</div>
</div>
<a class="anchor" id="ad4f7fa1ed25b92afed4de0cb957c313c"></a><!-- doxytag: member="ArRangeDevice::setCumulativeBufferSize" ref="ad4f7fa1ed25b92afed4de0cb957c313c" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setCumulativeBufferSize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum size of the buffer for cumulative readings. </p>
<p>If the <em>size</em> is smaller than the cumulative buffer size, then the oldest readings are discarded, leaving only <em>size</em> newest readings. If <em>size</em> is larger than the cumulative buffer size, then the buffer size will be allowed to grow to that size as new readings are added. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>number of readings to set the buffer to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classArLaser.html#a5a7f8511f5798fe69367435254871d05">ArLaser</a>.</p>

</div>
</div>
<a class="anchor" id="a0e73bae003a4e3f89f8bddfc843db464"></a><!-- doxytag: member="ArRangeDevice::setCurrentBufferSize" ref="a0e73bae003a4e3f89f8bddfc843db464" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setCurrentBufferSize </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum size of the buffer for current readings. </p>
<p>If the <em>size</em> is smaller than the current buffer size, then the oldest readings are discarded, leaving only <em>size</em> newest readings. If <em>size</em> is larger than the current size, then the buffer size will be allowed to grow to that size as new readings are added. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>number of readings to set the buffer's maximum size to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f1ec2efa5f2d6d34683586919847aa2"></a><!-- doxytag: member="ArRangeDevice::setMaxDistToKeepCumulative" ref="a3f1ec2efa5f2d6d34683586919847aa2" args="(double maxDistToKeepCumulative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxDistToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>maxDistToKeepCumulative</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets the maximum distance cumulative readings can be from current pose </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxDistToKeepCumulative</em>&nbsp;</td><td>if cumulative readings are further than this from where the current pose they are removed, if this is less than 0 they are not removed because of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65aaec7f213c343f6c096584928463cc"></a><!-- doxytag: member="ArRangeDevice::setMaxInsertDistCumulative" ref="a65aaec7f213c343f6c096584928463cc" args="(double maxInsertDistCumulative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxInsertDistCumulative </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>maxInsertDistCumulative</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum distance a cumulative reading can be from the robot and still be inserted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxInsertDistCumulative</em>&nbsp;</td><td>The maximum distance a cumulative reading can have from the robot's current position and still be inserted into the cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d797854910a43b6650fb4cee3d8626f"></a><!-- doxytag: member="ArRangeDevice::setMaxSecondsToKeepCumulative" ref="a6d797854910a43b6650fb4cee3d8626f" args="(int maxSecondsToKeepCumulative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxSecondsToKeepCumulative </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSecondsToKeepCumulative</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the maximum seconds to keep cumulative readings around </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCumulative</em>&nbsp;</td><td>this is the number of seconds to keep cumulative readings around, if less than 0 then they are not automatically removed because of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab963e49e5a08704ac08ab7eab040fa8c"></a><!-- doxytag: member="ArRangeDevice::setMaxSecondsToKeepCurrent" ref="ab963e49e5a08704ac08ab7eab040fa8c" args="(int maxSecondsToKeepCurrent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMaxSecondsToKeepCurrent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxSecondsToKeepCurrent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum seconds to keep current readings around. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCurrent</em>&nbsp;</td><td>this is the number of seconds to keep current readings around, if less than 0 then they are not automatically removed because of this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd53bf7cfbba205118c79ab95c8c3f18"></a><!-- doxytag: member="ArRangeDevice::setMinDistBetweenCumulative" ref="acd53bf7cfbba205118c79ab95c8c3f18" args="(double minDistBetweenCumulative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMinDistBetweenCumulative </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>minDistBetweenCumulative</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the minimum distance between cumulative readings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minDistBetweenCumulative</em>&nbsp;</td><td>The minimum distance between cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3b9e8840205f7d1b60a55f27490c1ab"></a><!-- doxytag: member="ArRangeDevice::setMinDistBetweenCurrent" ref="ab3b9e8840205f7d1b60a55f27490c1ab" args="(double minDistBetweenCurrent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ArRangeDevice::setMinDistBetweenCurrent </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>minDistBetweenCurrent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the minimum distance between current readings. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minDistBetweenCurrent</em>&nbsp;</td><td>The minimum distance between current readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ArRangeDevice.h</li>
<li>ArRangeDevice.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Aug 23 2011 16:44:29 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
